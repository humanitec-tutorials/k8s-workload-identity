# This Resource Definition uses the Terraform Driver to create a Kubernetes service account.
# It also creates the IAM policies for different kinds of Google Cloud Resources
# and binds them to the principal associated with the service account through GKE workload identity
apiVersion: entity.humanitec.io/v1b1
kind: Definition
metadata:
  id: custom-service-account-for-wi
entity:
  driver_type: humanitec/terraform
  name: custom-service-account-for-wi
  type: k8s-service-account
  # Obtain the Cloud Account from a config resource
  driver_account: ${resources['config.default#app-config'].account}
  driver_inputs:
    values:
      append_logs_to_error: true
      variables:
        app_id: "${context.app.id}"
        env_id: "${context.env.id}"
        res_id: "${context.res.id}"
        gke_project_id: ${resources['config.default#gke-config'].outputs.gke_project_id}
        gke_project_number: ${resources['config.default#gke-config'].outputs.gke_project_number}
        # Due to using the id `k8s-namespace`, this reference targets the implicitly created namespace resource
        k8s_namespace: "${resources['k8s-namespace.default#k8s-namespace'].outputs.namespace}"
        # The `gcp-iam-policy-bindings` in this selector are being co-provisioned by the respective cloud resources
        # E.g. the `gcs` resource co-provisions the policy binding for gcs
        iam_member_bindings: "${resources.workload>gcp-iam-policy-binding.outputs.binding}"
      credentials_config:
        variables:
          access_token: access_token
      manifests_output: "manifests"
      script: |-
        terraform {
          required_providers {
            google = {
              source  = "hashicorp/google"
            }
          }
        }
        provider "google" {
          access_token = var.access_token
          
          default_labels = {
            "humanitec"  = "true"
            "hum-app"    = var.app_id
            "hum-env"    = var.env_id
            "hum-res"    = replace(var.res_id, ".", "-")
            "managed-by" = "terraform"
          }
        }
        locals {
          workload_id = split(".", var.res_id)[1]
          parsed_iam_member_bindings = [for g in var.iam_member_bindings : jsondecode(g)]
          principal = "principal://iam.googleapis.com/projects/$\{var.gke_project_number}/locations/global/workloadIdentityPools/$\{var.gke_project_id}.svc.id.goog/subject/ns/$\{var.k8s_namespace}/sa/$\{local.workload_id}"
          manifests = [
            {
              location = "namespace"
              data     = {
                apiVersion : "v1",
                kind : "ServiceAccount",
                metadata : {
                  name : local.workload_id,
                  annotations : {
                    hum-res : var.res_id
                  }
                }
              }
            }
          ]
        }
        variable "access_token" {
          type      = string
          sensitive = true
        }
        variable "app_id" {
          type = string
        }
        variable "env_id" {
          type = string
        }
        variable "res_id" {
          type = string
        }
        variable "gke_project_id" {
          type = string
        }
        variable "gke_project_number" {
          type = string
        }
        variable "k8s_namespace" {
          type = string
        }
        variable "iam_member_bindings" {
          type = set(string)
        }
        resource "google_storage_bucket_iam_member" "iam_member" {
          for_each = {
            for g in local.parsed_iam_member_bindings : join("/", [g["bucket_name"], g["role"]]) => g if g["type"] == "gcs"
          }
          
          bucket  = each.value["bucket_name"]
          role    = each.value["role"]
          member  = local.principal
        }
        resource "google_project_iam_member" "vertex_ai_members" {
          for_each = {
            for g in local.parsed_iam_member_bindings : join("/", [g["project"], g["role"]]) => g if g["type"] == "gcp-vertex-ai"
          }

          project = each.value["project"]
          role    = each.value["role"]
          member  = local.principal
        }
        output "name" {
          value = local.workload_id
        }
        output "manifests" {
          value = local.manifests
        }
  # Adjust matching criteria as required
  criteria:
  - app_id: workload-identity-test